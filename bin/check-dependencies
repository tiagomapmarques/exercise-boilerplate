#!/usr/bin/env node

import { execAsync } from './common/exec.mjs';
import {
  error,
  hasLoggedError,
  hasLoggedInfoWarnOrError,
  info,
  log,
  warn,
} from './common/logs.mjs';
import { highlightSemver, parseSemver } from './common/semver.mjs';

const errorOnWarnings = process.argv[2] === '--error-on-warnings';

const getDependenciesVersions = async () => {
  const output = await execAsync('pnpm outdated --format json');

  return Object.fromEntries(
    Object.entries(JSON.parse(output.slice(output.indexOf('{')))),
  );
};

const sortByProdAndName = (left, right) => {
  const leftIsDev =
    outdatedDependencies[left].dependencyType === 'devDependencies';
  const rightIsDev =
    outdatedDependencies[right].dependencyType === 'devDependencies';

  if (leftIsDev && !rightIsDev) {
    return 1;
  }
  if (!leftIsDev && rightIsDev) {
    return -1;
  }
  if (left === right) {
    return 0;
  }
  return left > right ? 1 : -1;
};

const outdatedDependencies = await getDependenciesVersions();
const major = Object.keys(outdatedDependencies)
  .filter((dependency) => {
    const { current, latest } = outdatedDependencies[dependency];
    return parseSemver(latest).major > parseSemver(current).major;
  })
  .sort(sortByProdAndName);
const minorOrPatch = Object.keys(outdatedDependencies)
  .filter((dependency) => !major.includes(dependency))
  .sort(sortByProdAndName);

const printVersions = (dependencies, isImportant) => {
  const warnOrError = errorOnWarnings ? error : warn;
  const logger = isImportant ? warnOrError : info;

  if (dependencies.length > 0) {
    logger(
      `\nThe following packages have ${isImportant ? 'major' : 'minor/patch'} version updates:`,
    );
  }

  dependencies.forEach((dependency) => {
    const parsedLatest = parseSemver(outdatedDependencies[dependency].latest);
    const parsedCurrent = parseSemver(outdatedDependencies[dependency].current);
    const highlight = highlightSemver(parsedLatest, parsedCurrent);
    logger(
      `  ${dependency}: ${highlight} (current: ${outdatedDependencies[dependency].current})`,
    );
  });

  if (dependencies.length > 0) {
    logger('');
  }
};

printVersions(major, true);
printVersions(minorOrPatch, false);

if (!hasLoggedInfoWarnOrError()) {
  log('No outdated packages found');
}

if (hasLoggedError()) {
  process.exit(1);
}
