#!/usr/bin/env node
/** biome-ignore-all lint/suspicious/noConsole: Useful as this is a script */
import { exec } from 'node:child_process';
import { readFileSync } from 'node:fs';

const packageJsonFile = `${import.meta.dirname}/../package.json`;

const getPnpmVersions = async () => {
  let output = '';
  try {
    output = await new Promise((resolve) => {
      exec('pnpm self-update 100', (_error, stdout) => resolve(stdout));
    });
  } finally {
    output =
      output
        .split('\n')
        .filter((line) => line.includes('latest-'))
        .pop() || '';
  }
  return {
    latest: output.split(': ').pop() || '',
    lts: undefined,
  };
};

const getNodeVersions = async () => {
  const response = await fetch(
    'https://nodejs.org/download/release/index.json',
  );
  const data = await response.json();
  return {
    latest: data.find((item) => !item.lts)?.version.slice(1),
    lts: data.find((item) => item.lts)?.version.slice(1),
  };
};

const getLatestVersions = async () => {
  const [pnpmVersions, nodeVersions] = await Promise.all([
    getPnpmVersions(),
    getNodeVersions(),
  ]);

  return {
    node: nodeVersions,
    pnpm: pnpmVersions,
  };
};

const getCurrentVersions = () => {
  const { engines } = JSON.parse(readFileSync(packageJsonFile).toString());

  const [latestNode, ltsNode] = engines.node
    .replaceAll('^', '')
    .split('||')
    .map((version) => version.trim());

  const [latestPnpm, ltsPnpm] = engines.pnpm
    .replaceAll('^', '')
    .split('||')
    .map((version) => version.trim());

  return {
    node: { latest: latestNode, lts: ltsNode },
    pnpm: { latest: latestPnpm, lts: ltsPnpm },
  };
};

const latestVersions = await getLatestVersions();
const currentVersions = getCurrentVersions();
let warnings = false;

if (
  currentVersions.node.lts &&
  currentVersions.node.lts !== latestVersions.node.lts
) {
  warnings = true;
  console.log(
    '\x1b[43m%s\x1b[0m',
    ' WARN ',
    `Newer \`node\` LTS version available: ${latestVersions.node.lts} (current: ${currentVersions.node.lts})`,
  );
}

if (
  currentVersions.pnpm.lts &&
  currentVersions.pnpm.lts !== latestVersions.pnpm.lts
) {
  warnings = true;
  console.log(
    '\x1b[43m%s\x1b[0m',
    ' WARN ',
    `Newer \`pnpm\` LTS version available: ${latestVersions.pnpm.lts} (current: ${currentVersions.pnpm.lts})`,
  );
}

if (currentVersions.node.latest !== latestVersions.node.latest) {
  warnings = true;
  console.log(
    '\x1b[33m%s\x1b[0m',
    '_INFO_',
    `Newer \`node\` version available: ${latestVersions.node.latest} (current: ${currentVersions.node.latest})`,
  );
}

if (currentVersions.pnpm.latest !== latestVersions.pnpm.latest) {
  warnings = true;
  console.log(
    '\x1b[33m%s\x1b[0m',
    '_INFO_',
    `Newer \`pnpm\` version available: ${latestVersions.pnpm.latest} (current: ${currentVersions.pnpm.latest})`,
  );
}

if (!warnings) {
  console.log('No engine updates found');
}
